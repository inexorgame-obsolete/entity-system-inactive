// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: entity-system.proto

#ifndef PROTOBUF_INCLUDED_entity_2dsystem_2eproto
#define PROTOBUF_INCLUDED_entity_2dsystem_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_entity_2dsystem_2eproto 

namespace protobuf_entity_2dsystem_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_entity_2dsystem_2eproto
namespace inexor {
namespace entity_system {
class EntityAttributeType;
class EntityAttributeTypeDefaultTypeInternal;
extern EntityAttributeTypeDefaultTypeInternal _EntityAttributeType_default_instance_;
class EntityOperation;
class EntityOperationDefaultTypeInternal;
extern EntityOperationDefaultTypeInternal _EntityOperation_default_instance_;
class EntityRelationAttributeType;
class EntityRelationAttributeTypeDefaultTypeInternal;
extern EntityRelationAttributeTypeDefaultTypeInternal _EntityRelationAttributeType_default_instance_;
class EntityRelationType;
class EntityRelationTypeDefaultTypeInternal;
extern EntityRelationTypeDefaultTypeInternal _EntityRelationType_default_instance_;
class EntityType;
class EntityTypeDefaultTypeInternal;
extern EntityTypeDefaultTypeInternal _EntityType_default_instance_;
}  // namespace entity_system
}  // namespace inexor
namespace google {
namespace protobuf {
template<> ::inexor::entity_system::EntityAttributeType* Arena::CreateMaybeMessage<::inexor::entity_system::EntityAttributeType>(Arena*);
template<> ::inexor::entity_system::EntityOperation* Arena::CreateMaybeMessage<::inexor::entity_system::EntityOperation>(Arena*);
template<> ::inexor::entity_system::EntityRelationAttributeType* Arena::CreateMaybeMessage<::inexor::entity_system::EntityRelationAttributeType>(Arena*);
template<> ::inexor::entity_system::EntityRelationType* Arena::CreateMaybeMessage<::inexor::entity_system::EntityRelationType>(Arena*);
template<> ::inexor::entity_system::EntityType* Arena::CreateMaybeMessage<::inexor::entity_system::EntityType>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace inexor {
namespace entity_system {

enum ENTSYS_RESULT {
  ENTSYS_ERROR = 0,
  ENTSYS_SUCCESS = 1,
  ENTSYS_RESULT_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ENTSYS_RESULT_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ENTSYS_RESULT_IsValid(int value);
const ENTSYS_RESULT ENTSYS_RESULT_MIN = ENTSYS_ERROR;
const ENTSYS_RESULT ENTSYS_RESULT_MAX = ENTSYS_SUCCESS;
const int ENTSYS_RESULT_ARRAYSIZE = ENTSYS_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTSYS_RESULT_descriptor();
inline const ::std::string& ENTSYS_RESULT_Name(ENTSYS_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTSYS_RESULT_descriptor(), value);
}
inline bool ENTSYS_RESULT_Parse(
    const ::std::string& name, ENTSYS_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTSYS_RESULT>(
    ENTSYS_RESULT_descriptor(), name, value);
}
enum ENTSYS_ERROR_LEVEL {
  ENTSYS_LEVEL_INFO = 0,
  ENTSYS_LEVEL_WARNING = 1,
  ENTSYS_LEVEL_ERROR = 2,
  ENTSYS_LEVEL_CRITICAL_ERROR = 3,
  ENTSYS_ERROR_LEVEL_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ENTSYS_ERROR_LEVEL_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ENTSYS_ERROR_LEVEL_IsValid(int value);
const ENTSYS_ERROR_LEVEL ENTSYS_ERROR_LEVEL_MIN = ENTSYS_LEVEL_INFO;
const ENTSYS_ERROR_LEVEL ENTSYS_ERROR_LEVEL_MAX = ENTSYS_LEVEL_CRITICAL_ERROR;
const int ENTSYS_ERROR_LEVEL_ARRAYSIZE = ENTSYS_ERROR_LEVEL_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTSYS_ERROR_LEVEL_descriptor();
inline const ::std::string& ENTSYS_ERROR_LEVEL_Name(ENTSYS_ERROR_LEVEL value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTSYS_ERROR_LEVEL_descriptor(), value);
}
inline bool ENTSYS_ERROR_LEVEL_Parse(
    const ::std::string& name, ENTSYS_ERROR_LEVEL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTSYS_ERROR_LEVEL>(
    ENTSYS_ERROR_LEVEL_descriptor(), name, value);
}
enum ENTSYS_DATA_VALIDATION_RESULT {
  ENTSYS_DATA_INVALID = 0,
  ENTSYS_DATA_VALID = 1,
  ENTSYS_DATA_VALIDATION_RESULT_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ENTSYS_DATA_VALIDATION_RESULT_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ENTSYS_DATA_VALIDATION_RESULT_IsValid(int value);
const ENTSYS_DATA_VALIDATION_RESULT ENTSYS_DATA_VALIDATION_RESULT_MIN = ENTSYS_DATA_INVALID;
const ENTSYS_DATA_VALIDATION_RESULT ENTSYS_DATA_VALIDATION_RESULT_MAX = ENTSYS_DATA_VALID;
const int ENTSYS_DATA_VALIDATION_RESULT_ARRAYSIZE = ENTSYS_DATA_VALIDATION_RESULT_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTSYS_DATA_VALIDATION_RESULT_descriptor();
inline const ::std::string& ENTSYS_DATA_VALIDATION_RESULT_Name(ENTSYS_DATA_VALIDATION_RESULT value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTSYS_DATA_VALIDATION_RESULT_descriptor(), value);
}
inline bool ENTSYS_DATA_VALIDATION_RESULT_Parse(
    const ::std::string& name, ENTSYS_DATA_VALIDATION_RESULT* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTSYS_DATA_VALIDATION_RESULT>(
    ENTSYS_DATA_VALIDATION_RESULT_descriptor(), name, value);
}
enum ENTSYS_DATA_TYPE {
  ENTSYS_DATA_TYPE_UNDEFINED = 0,
  ENTSYS_DATA_TYPE_INT = 1,
  ENTSYS_DATA_TYPE_BIG_INT = 2,
  ENTSYS_DATA_TYPE_FLOAT = 3,
  ENTSYS_DATA_TYPE_STRING = 4,
  ENTSYS_DATA_TYPE_DOUBLE = 5,
  ENTSYS_DATA_TYPE_BOOL = 6,
  ENTSYS_DATA_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ENTSYS_DATA_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ENTSYS_DATA_TYPE_IsValid(int value);
const ENTSYS_DATA_TYPE ENTSYS_DATA_TYPE_MIN = ENTSYS_DATA_TYPE_UNDEFINED;
const ENTSYS_DATA_TYPE ENTSYS_DATA_TYPE_MAX = ENTSYS_DATA_TYPE_BOOL;
const int ENTSYS_DATA_TYPE_ARRAYSIZE = ENTSYS_DATA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ENTSYS_DATA_TYPE_descriptor();
inline const ::std::string& ENTSYS_DATA_TYPE_Name(ENTSYS_DATA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ENTSYS_DATA_TYPE_descriptor(), value);
}
inline bool ENTSYS_DATA_TYPE_Parse(
    const ::std::string& name, ENTSYS_DATA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ENTSYS_DATA_TYPE>(
    ENTSYS_DATA_TYPE_descriptor(), name, value);
}
// ===================================================================

class EntityAttributeType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:inexor.entity_system.EntityAttributeType) */ {
 public:
  EntityAttributeType();
  virtual ~EntityAttributeType();

  EntityAttributeType(const EntityAttributeType& from);

  inline EntityAttributeType& operator=(const EntityAttributeType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityAttributeType(EntityAttributeType&& from) noexcept
    : EntityAttributeType() {
    *this = ::std::move(from);
  }

  inline EntityAttributeType& operator=(EntityAttributeType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityAttributeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityAttributeType* internal_default_instance() {
    return reinterpret_cast<const EntityAttributeType*>(
               &_EntityAttributeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EntityAttributeType* other);
  friend void swap(EntityAttributeType& a, EntityAttributeType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityAttributeType* New() const final {
    return CreateMaybeMessage<EntityAttributeType>(NULL);
  }

  EntityAttributeType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityAttributeType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityAttributeType& from);
  void MergeFrom(const EntityAttributeType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityAttributeType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ent_attr_type_name = 1;
  void clear_ent_attr_type_name();
  static const int kEntAttrTypeNameFieldNumber = 1;
  const ::std::string& ent_attr_type_name() const;
  void set_ent_attr_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ent_attr_type_name(::std::string&& value);
  #endif
  void set_ent_attr_type_name(const char* value);
  void set_ent_attr_type_name(const char* value, size_t size);
  ::std::string* mutable_ent_attr_type_name();
  ::std::string* release_ent_attr_type_name();
  void set_allocated_ent_attr_type_name(::std::string* ent_attr_type_name);

  // .inexor.entity_system.ENTSYS_DATA_TYPE ent_attr_data_type = 2;
  void clear_ent_attr_data_type();
  static const int kEntAttrDataTypeFieldNumber = 2;
  ::inexor::entity_system::ENTSYS_DATA_TYPE ent_attr_data_type() const;
  void set_ent_attr_data_type(::inexor::entity_system::ENTSYS_DATA_TYPE value);

  // @@protoc_insertion_point(class_scope:inexor.entity_system.EntityAttributeType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ent_attr_type_name_;
  int ent_attr_data_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_entity_2dsystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:inexor.entity_system.EntityType) */ {
 public:
  EntityType();
  virtual ~EntityType();

  EntityType(const EntityType& from);

  inline EntityType& operator=(const EntityType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityType(EntityType&& from) noexcept
    : EntityType() {
    *this = ::std::move(from);
  }

  inline EntityType& operator=(EntityType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityType* internal_default_instance() {
    return reinterpret_cast<const EntityType*>(
               &_EntityType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(EntityType* other);
  friend void swap(EntityType& a, EntityType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityType* New() const final {
    return CreateMaybeMessage<EntityType>(NULL);
  }

  EntityType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityType& from);
  void MergeFrom(const EntityType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ent_type_name = 1;
  void clear_ent_type_name();
  static const int kEntTypeNameFieldNumber = 1;
  const ::std::string& ent_type_name() const;
  void set_ent_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ent_type_name(::std::string&& value);
  #endif
  void set_ent_type_name(const char* value);
  void set_ent_type_name(const char* value, size_t size);
  ::std::string* mutable_ent_type_name();
  ::std::string* release_ent_type_name();
  void set_allocated_ent_type_name(::std::string* ent_type_name);

  // @@protoc_insertion_point(class_scope:inexor.entity_system.EntityType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ent_type_name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_entity_2dsystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityRelationAttributeType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:inexor.entity_system.EntityRelationAttributeType) */ {
 public:
  EntityRelationAttributeType();
  virtual ~EntityRelationAttributeType();

  EntityRelationAttributeType(const EntityRelationAttributeType& from);

  inline EntityRelationAttributeType& operator=(const EntityRelationAttributeType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityRelationAttributeType(EntityRelationAttributeType&& from) noexcept
    : EntityRelationAttributeType() {
    *this = ::std::move(from);
  }

  inline EntityRelationAttributeType& operator=(EntityRelationAttributeType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityRelationAttributeType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityRelationAttributeType* internal_default_instance() {
    return reinterpret_cast<const EntityRelationAttributeType*>(
               &_EntityRelationAttributeType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EntityRelationAttributeType* other);
  friend void swap(EntityRelationAttributeType& a, EntityRelationAttributeType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityRelationAttributeType* New() const final {
    return CreateMaybeMessage<EntityRelationAttributeType>(NULL);
  }

  EntityRelationAttributeType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityRelationAttributeType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityRelationAttributeType& from);
  void MergeFrom(const EntityRelationAttributeType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityRelationAttributeType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ent_rel_attr_type_name = 1;
  void clear_ent_rel_attr_type_name();
  static const int kEntRelAttrTypeNameFieldNumber = 1;
  const ::std::string& ent_rel_attr_type_name() const;
  void set_ent_rel_attr_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ent_rel_attr_type_name(::std::string&& value);
  #endif
  void set_ent_rel_attr_type_name(const char* value);
  void set_ent_rel_attr_type_name(const char* value, size_t size);
  ::std::string* mutable_ent_rel_attr_type_name();
  ::std::string* release_ent_rel_attr_type_name();
  void set_allocated_ent_rel_attr_type_name(::std::string* ent_rel_attr_type_name);

  // .inexor.entity_system.ENTSYS_DATA_TYPE ent_rel_attr_type_data_type = 2;
  void clear_ent_rel_attr_type_data_type();
  static const int kEntRelAttrTypeDataTypeFieldNumber = 2;
  ::inexor::entity_system::ENTSYS_DATA_TYPE ent_rel_attr_type_data_type() const;
  void set_ent_rel_attr_type_data_type(::inexor::entity_system::ENTSYS_DATA_TYPE value);

  // @@protoc_insertion_point(class_scope:inexor.entity_system.EntityRelationAttributeType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ent_rel_attr_type_name_;
  int ent_rel_attr_type_data_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_entity_2dsystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityRelationType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:inexor.entity_system.EntityRelationType) */ {
 public:
  EntityRelationType();
  virtual ~EntityRelationType();

  EntityRelationType(const EntityRelationType& from);

  inline EntityRelationType& operator=(const EntityRelationType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityRelationType(EntityRelationType&& from) noexcept
    : EntityRelationType() {
    *this = ::std::move(from);
  }

  inline EntityRelationType& operator=(EntityRelationType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityRelationType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityRelationType* internal_default_instance() {
    return reinterpret_cast<const EntityRelationType*>(
               &_EntityRelationType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EntityRelationType* other);
  friend void swap(EntityRelationType& a, EntityRelationType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityRelationType* New() const final {
    return CreateMaybeMessage<EntityRelationType>(NULL);
  }

  EntityRelationType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityRelationType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityRelationType& from);
  void MergeFrom(const EntityRelationType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityRelationType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string rel_type_name = 1;
  void clear_rel_type_name();
  static const int kRelTypeNameFieldNumber = 1;
  const ::std::string& rel_type_name() const;
  void set_rel_type_name(const ::std::string& value);
  #if LANG_CXX11
  void set_rel_type_name(::std::string&& value);
  #endif
  void set_rel_type_name(const char* value);
  void set_rel_type_name(const char* value, size_t size);
  ::std::string* mutable_rel_type_name();
  ::std::string* release_rel_type_name();
  void set_allocated_rel_type_name(::std::string* rel_type_name);

  // .inexor.entity_system.EntityType ent_type_source = 2;
  bool has_ent_type_source() const;
  void clear_ent_type_source();
  static const int kEntTypeSourceFieldNumber = 2;
  private:
  const ::inexor::entity_system::EntityType& _internal_ent_type_source() const;
  public:
  const ::inexor::entity_system::EntityType& ent_type_source() const;
  ::inexor::entity_system::EntityType* release_ent_type_source();
  ::inexor::entity_system::EntityType* mutable_ent_type_source();
  void set_allocated_ent_type_source(::inexor::entity_system::EntityType* ent_type_source);

  // .inexor.entity_system.EntityType ent_type_target = 3;
  bool has_ent_type_target() const;
  void clear_ent_type_target();
  static const int kEntTypeTargetFieldNumber = 3;
  private:
  const ::inexor::entity_system::EntityType& _internal_ent_type_target() const;
  public:
  const ::inexor::entity_system::EntityType& ent_type_target() const;
  ::inexor::entity_system::EntityType* release_ent_type_target();
  ::inexor::entity_system::EntityType* mutable_ent_type_target();
  void set_allocated_ent_type_target(::inexor::entity_system::EntityType* ent_type_target);

  // @@protoc_insertion_point(class_scope:inexor.entity_system.EntityRelationType)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr rel_type_name_;
  ::inexor::entity_system::EntityType* ent_type_source_;
  ::inexor::entity_system::EntityType* ent_type_target_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_entity_2dsystem_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityOperation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:inexor.entity_system.EntityOperation) */ {
 public:
  EntityOperation();
  virtual ~EntityOperation();

  EntityOperation(const EntityOperation& from);

  inline EntityOperation& operator=(const EntityOperation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityOperation(EntityOperation&& from) noexcept
    : EntityOperation() {
    *this = ::std::move(from);
  }

  inline EntityOperation& operator=(EntityOperation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityOperation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityOperation* internal_default_instance() {
    return reinterpret_cast<const EntityOperation*>(
               &_EntityOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(EntityOperation* other);
  friend void swap(EntityOperation& a, EntityOperation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityOperation* New() const final {
    return CreateMaybeMessage<EntityOperation>(NULL);
  }

  EntityOperation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityOperation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityOperation& from);
  void MergeFrom(const EntityOperation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .inexor.entity_system.ENTSYS_RESULT result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::inexor::entity_system::ENTSYS_RESULT result() const;
  void set_result(::inexor::entity_system::ENTSYS_RESULT value);

  // @@protoc_insertion_point(class_scope:inexor.entity_system.EntityOperation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int result_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_entity_2dsystem_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EntityAttributeType

// string ent_attr_type_name = 1;
inline void EntityAttributeType::clear_ent_attr_type_name() {
  ent_attr_type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityAttributeType::ent_attr_type_name() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
  return ent_attr_type_name_.GetNoArena();
}
inline void EntityAttributeType::set_ent_attr_type_name(const ::std::string& value) {
  
  ent_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
}
#if LANG_CXX11
inline void EntityAttributeType::set_ent_attr_type_name(::std::string&& value) {
  
  ent_attr_type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
}
#endif
inline void EntityAttributeType::set_ent_attr_type_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ent_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
}
inline void EntityAttributeType::set_ent_attr_type_name(const char* value, size_t size) {
  
  ent_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
}
inline ::std::string* EntityAttributeType::mutable_ent_attr_type_name() {
  
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
  return ent_attr_type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityAttributeType::release_ent_attr_type_name() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
  
  return ent_attr_type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityAttributeType::set_allocated_ent_attr_type_name(::std::string* ent_attr_type_name) {
  if (ent_attr_type_name != NULL) {
    
  } else {
    
  }
  ent_attr_type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ent_attr_type_name);
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityAttributeType.ent_attr_type_name)
}

// .inexor.entity_system.ENTSYS_DATA_TYPE ent_attr_data_type = 2;
inline void EntityAttributeType::clear_ent_attr_data_type() {
  ent_attr_data_type_ = 0;
}
inline ::inexor::entity_system::ENTSYS_DATA_TYPE EntityAttributeType::ent_attr_data_type() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityAttributeType.ent_attr_data_type)
  return static_cast< ::inexor::entity_system::ENTSYS_DATA_TYPE >(ent_attr_data_type_);
}
inline void EntityAttributeType::set_ent_attr_data_type(::inexor::entity_system::ENTSYS_DATA_TYPE value) {
  
  ent_attr_data_type_ = value;
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityAttributeType.ent_attr_data_type)
}

// -------------------------------------------------------------------

// EntityType

// string ent_type_name = 1;
inline void EntityType::clear_ent_type_name() {
  ent_type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityType::ent_type_name() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityType.ent_type_name)
  return ent_type_name_.GetNoArena();
}
inline void EntityType::set_ent_type_name(const ::std::string& value) {
  
  ent_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityType.ent_type_name)
}
#if LANG_CXX11
inline void EntityType::set_ent_type_name(::std::string&& value) {
  
  ent_type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:inexor.entity_system.EntityType.ent_type_name)
}
#endif
inline void EntityType::set_ent_type_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ent_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:inexor.entity_system.EntityType.ent_type_name)
}
inline void EntityType::set_ent_type_name(const char* value, size_t size) {
  
  ent_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:inexor.entity_system.EntityType.ent_type_name)
}
inline ::std::string* EntityType::mutable_ent_type_name() {
  
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityType.ent_type_name)
  return ent_type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityType::release_ent_type_name() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityType.ent_type_name)
  
  return ent_type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityType::set_allocated_ent_type_name(::std::string* ent_type_name) {
  if (ent_type_name != NULL) {
    
  } else {
    
  }
  ent_type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ent_type_name);
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityType.ent_type_name)
}

// -------------------------------------------------------------------

// EntityRelationAttributeType

// string ent_rel_attr_type_name = 1;
inline void EntityRelationAttributeType::clear_ent_rel_attr_type_name() {
  ent_rel_attr_type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityRelationAttributeType::ent_rel_attr_type_name() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
  return ent_rel_attr_type_name_.GetNoArena();
}
inline void EntityRelationAttributeType::set_ent_rel_attr_type_name(const ::std::string& value) {
  
  ent_rel_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
}
#if LANG_CXX11
inline void EntityRelationAttributeType::set_ent_rel_attr_type_name(::std::string&& value) {
  
  ent_rel_attr_type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
}
#endif
inline void EntityRelationAttributeType::set_ent_rel_attr_type_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ent_rel_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
}
inline void EntityRelationAttributeType::set_ent_rel_attr_type_name(const char* value, size_t size) {
  
  ent_rel_attr_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
}
inline ::std::string* EntityRelationAttributeType::mutable_ent_rel_attr_type_name() {
  
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
  return ent_rel_attr_type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityRelationAttributeType::release_ent_rel_attr_type_name() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
  
  return ent_rel_attr_type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityRelationAttributeType::set_allocated_ent_rel_attr_type_name(::std::string* ent_rel_attr_type_name) {
  if (ent_rel_attr_type_name != NULL) {
    
  } else {
    
  }
  ent_rel_attr_type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ent_rel_attr_type_name);
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_name)
}

// .inexor.entity_system.ENTSYS_DATA_TYPE ent_rel_attr_type_data_type = 2;
inline void EntityRelationAttributeType::clear_ent_rel_attr_type_data_type() {
  ent_rel_attr_type_data_type_ = 0;
}
inline ::inexor::entity_system::ENTSYS_DATA_TYPE EntityRelationAttributeType::ent_rel_attr_type_data_type() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_data_type)
  return static_cast< ::inexor::entity_system::ENTSYS_DATA_TYPE >(ent_rel_attr_type_data_type_);
}
inline void EntityRelationAttributeType::set_ent_rel_attr_type_data_type(::inexor::entity_system::ENTSYS_DATA_TYPE value) {
  
  ent_rel_attr_type_data_type_ = value;
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityRelationAttributeType.ent_rel_attr_type_data_type)
}

// -------------------------------------------------------------------

// EntityRelationType

// string rel_type_name = 1;
inline void EntityRelationType::clear_rel_type_name() {
  rel_type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EntityRelationType::rel_type_name() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityRelationType.rel_type_name)
  return rel_type_name_.GetNoArena();
}
inline void EntityRelationType::set_rel_type_name(const ::std::string& value) {
  
  rel_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityRelationType.rel_type_name)
}
#if LANG_CXX11
inline void EntityRelationType::set_rel_type_name(::std::string&& value) {
  
  rel_type_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:inexor.entity_system.EntityRelationType.rel_type_name)
}
#endif
inline void EntityRelationType::set_rel_type_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  rel_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:inexor.entity_system.EntityRelationType.rel_type_name)
}
inline void EntityRelationType::set_rel_type_name(const char* value, size_t size) {
  
  rel_type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:inexor.entity_system.EntityRelationType.rel_type_name)
}
inline ::std::string* EntityRelationType::mutable_rel_type_name() {
  
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityRelationType.rel_type_name)
  return rel_type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntityRelationType::release_rel_type_name() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityRelationType.rel_type_name)
  
  return rel_type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntityRelationType::set_allocated_rel_type_name(::std::string* rel_type_name) {
  if (rel_type_name != NULL) {
    
  } else {
    
  }
  rel_type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rel_type_name);
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityRelationType.rel_type_name)
}

// .inexor.entity_system.EntityType ent_type_source = 2;
inline bool EntityRelationType::has_ent_type_source() const {
  return this != internal_default_instance() && ent_type_source_ != NULL;
}
inline void EntityRelationType::clear_ent_type_source() {
  if (GetArenaNoVirtual() == NULL && ent_type_source_ != NULL) {
    delete ent_type_source_;
  }
  ent_type_source_ = NULL;
}
inline const ::inexor::entity_system::EntityType& EntityRelationType::_internal_ent_type_source() const {
  return *ent_type_source_;
}
inline const ::inexor::entity_system::EntityType& EntityRelationType::ent_type_source() const {
  const ::inexor::entity_system::EntityType* p = ent_type_source_;
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityRelationType.ent_type_source)
  return p != NULL ? *p : *reinterpret_cast<const ::inexor::entity_system::EntityType*>(
      &::inexor::entity_system::_EntityType_default_instance_);
}
inline ::inexor::entity_system::EntityType* EntityRelationType::release_ent_type_source() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityRelationType.ent_type_source)
  
  ::inexor::entity_system::EntityType* temp = ent_type_source_;
  ent_type_source_ = NULL;
  return temp;
}
inline ::inexor::entity_system::EntityType* EntityRelationType::mutable_ent_type_source() {
  
  if (ent_type_source_ == NULL) {
    auto* p = CreateMaybeMessage<::inexor::entity_system::EntityType>(GetArenaNoVirtual());
    ent_type_source_ = p;
  }
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityRelationType.ent_type_source)
  return ent_type_source_;
}
inline void EntityRelationType::set_allocated_ent_type_source(::inexor::entity_system::EntityType* ent_type_source) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ent_type_source_;
  }
  if (ent_type_source) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ent_type_source = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ent_type_source, submessage_arena);
    }
    
  } else {
    
  }
  ent_type_source_ = ent_type_source;
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityRelationType.ent_type_source)
}

// .inexor.entity_system.EntityType ent_type_target = 3;
inline bool EntityRelationType::has_ent_type_target() const {
  return this != internal_default_instance() && ent_type_target_ != NULL;
}
inline void EntityRelationType::clear_ent_type_target() {
  if (GetArenaNoVirtual() == NULL && ent_type_target_ != NULL) {
    delete ent_type_target_;
  }
  ent_type_target_ = NULL;
}
inline const ::inexor::entity_system::EntityType& EntityRelationType::_internal_ent_type_target() const {
  return *ent_type_target_;
}
inline const ::inexor::entity_system::EntityType& EntityRelationType::ent_type_target() const {
  const ::inexor::entity_system::EntityType* p = ent_type_target_;
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityRelationType.ent_type_target)
  return p != NULL ? *p : *reinterpret_cast<const ::inexor::entity_system::EntityType*>(
      &::inexor::entity_system::_EntityType_default_instance_);
}
inline ::inexor::entity_system::EntityType* EntityRelationType::release_ent_type_target() {
  // @@protoc_insertion_point(field_release:inexor.entity_system.EntityRelationType.ent_type_target)
  
  ::inexor::entity_system::EntityType* temp = ent_type_target_;
  ent_type_target_ = NULL;
  return temp;
}
inline ::inexor::entity_system::EntityType* EntityRelationType::mutable_ent_type_target() {
  
  if (ent_type_target_ == NULL) {
    auto* p = CreateMaybeMessage<::inexor::entity_system::EntityType>(GetArenaNoVirtual());
    ent_type_target_ = p;
  }
  // @@protoc_insertion_point(field_mutable:inexor.entity_system.EntityRelationType.ent_type_target)
  return ent_type_target_;
}
inline void EntityRelationType::set_allocated_ent_type_target(::inexor::entity_system::EntityType* ent_type_target) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ent_type_target_;
  }
  if (ent_type_target) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ent_type_target = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ent_type_target, submessage_arena);
    }
    
  } else {
    
  }
  ent_type_target_ = ent_type_target;
  // @@protoc_insertion_point(field_set_allocated:inexor.entity_system.EntityRelationType.ent_type_target)
}

// -------------------------------------------------------------------

// EntityOperation

// .inexor.entity_system.ENTSYS_RESULT result = 1;
inline void EntityOperation::clear_result() {
  result_ = 0;
}
inline ::inexor::entity_system::ENTSYS_RESULT EntityOperation::result() const {
  // @@protoc_insertion_point(field_get:inexor.entity_system.EntityOperation.result)
  return static_cast< ::inexor::entity_system::ENTSYS_RESULT >(result_);
}
inline void EntityOperation::set_result(::inexor::entity_system::ENTSYS_RESULT value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:inexor.entity_system.EntityOperation.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace entity_system
}  // namespace inexor

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::inexor::entity_system::ENTSYS_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inexor::entity_system::ENTSYS_RESULT>() {
  return ::inexor::entity_system::ENTSYS_RESULT_descriptor();
}
template <> struct is_proto_enum< ::inexor::entity_system::ENTSYS_ERROR_LEVEL> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inexor::entity_system::ENTSYS_ERROR_LEVEL>() {
  return ::inexor::entity_system::ENTSYS_ERROR_LEVEL_descriptor();
}
template <> struct is_proto_enum< ::inexor::entity_system::ENTSYS_DATA_VALIDATION_RESULT> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inexor::entity_system::ENTSYS_DATA_VALIDATION_RESULT>() {
  return ::inexor::entity_system::ENTSYS_DATA_VALIDATION_RESULT_descriptor();
}
template <> struct is_proto_enum< ::inexor::entity_system::ENTSYS_DATA_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::inexor::entity_system::ENTSYS_DATA_TYPE>() {
  return ::inexor::entity_system::ENTSYS_DATA_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_entity_2dsystem_2eproto
